# T-007: Application - FetchTranscriptUseCase

| Campo | Valor |
|-------|-------|
| **Tamanho** | M |
| **Prioridade** | Must Have |
| **Epic** | Transcript |
| **Depende de** | T-005, T-006 |
| **TDD** | Recomendado (80%) |

---

## Contexto

Criar use case que orquestra busca de transcricao: primeiro verifica cache (PostgreSQL), se nao existir busca do YouTube e salva no cache.

## Objetivo

Use case completo para buscar transcricao com logica de cache (cache-first strategy).

## Escopo

- Implementar FetchTranscriptUseCase
- Implementar ChunkTranscriptUseCase (dividir em chunks)
- Logica de cache: verificar banco → buscar YouTube → salvar banco
- Testes TDD com mocks de repositorio e service

## Arquivos a Criar

```
src/features/transcript/
└── application/
    └── use-cases/
        ├── fetch-transcript.ts
        └── chunk-transcript.ts

tests/unit/features/transcript/
└── application/
    ├── fetch-transcript.test.ts
    └── chunk-transcript.test.ts
```

## Implementacao (TDD)

### 1. ChunkTranscriptUseCase

```typescript
// PRIMEIRO: teste
// tests/unit/features/transcript/application/chunk-transcript.test.ts
describe('ChunkTranscriptUseCase', () => {
  it('should divide transcript into ~30s chunks', () => {
    const segments = [
      { text: 'Hello', offset: 0, duration: 10000 },
      { text: 'World', offset: 10000, duration: 10000 },
      { text: 'Test', offset: 20000, duration: 10000 },
      { text: 'More', offset: 30000, duration: 10000 },
    ]

    const useCase = new ChunkTranscriptUseCase()
    const chunks = useCase.execute(segments)

    expect(chunks.length).toBeGreaterThan(0)
    expect(chunks[0].endTime - chunks[0].startTime).toBeLessThanOrEqual(30)
  })
})
```

### 2. FetchTranscriptUseCase

```typescript
// PRIMEIRO: teste
// tests/unit/features/transcript/application/fetch-transcript.test.ts
describe('FetchTranscriptUseCase', () => {
  it('should return cached transcript if exists', async () => {
    const mockRepo = {
      findByVideoId: vi.fn().mockResolvedValue(cachedTranscript),
      save: vi.fn()
    }
    const mockFetcher = { fetch: vi.fn() }

    const useCase = new FetchTranscriptUseCase(mockRepo, mockFetcher, mockChunker)
    const result = await useCase.execute('https://youtu.be/abc123')

    expect(result.isSuccess).toBe(true)
    expect(mockRepo.findByVideoId).toHaveBeenCalled()
    expect(mockFetcher.fetch).not.toHaveBeenCalled() // Nao busca do YouTube
  })

  it('should fetch from YouTube and cache if not cached', async () => {
    const mockRepo = {
      findByVideoId: vi.fn().mockResolvedValue(null), // Nao tem cache
      save: vi.fn()
    }
    const mockFetcher = {
      fetch: vi.fn().mockResolvedValue(Result.ok(rawTranscript))
    }

    const useCase = new FetchTranscriptUseCase(mockRepo, mockFetcher, mockChunker)
    const result = await useCase.execute('https://youtu.be/abc123')

    expect(result.isSuccess).toBe(true)
    expect(mockFetcher.fetch).toHaveBeenCalled() // Busca do YouTube
    expect(mockRepo.save).toHaveBeenCalled() // Salva no cache
  })
})

// DEPOIS: implementacao
// src/features/transcript/application/use-cases/fetch-transcript.ts
export class FetchTranscriptUseCase {
  constructor(
    private readonly transcriptRepo: TranscriptRepository,
    private readonly transcriptFetcher: TranscriptFetcher,
    private readonly chunker: ChunkTranscriptUseCase
  ) {}

  async execute(videoUrl: string): Promise<Result<Transcript, FetchTranscriptError>> {
    // 1. Extrair VideoId
    const videoIdResult = VideoId.fromUrl(videoUrl)
    if (videoIdResult.isFailure) {
      return Result.fail(new InvalidVideoUrlError(videoUrl))
    }
    const videoId = videoIdResult.value

    // 2. Verificar cache
    const cached = await this.transcriptRepo.findByVideoId(videoId)
    if (cached) {
      return Result.ok(cached) // Cache HIT
    }

    // 3. Buscar do YouTube
    const fetchResult = await this.transcriptFetcher.fetch(videoId)
    if (fetchResult.isFailure) {
      return Result.fail(fetchResult.error)
    }

    // 4. Dividir em chunks
    const chunks = this.chunker.execute(fetchResult.value.segments)

    // 5. Criar entidade
    const transcript = Transcript.create({
      videoId,
      title: fetchResult.value.title,
      fullText: fetchResult.value.segments.map(s => s.text).join(' '),
      chunks
    })

    // 6. Salvar no cache
    await this.transcriptRepo.save(transcript.value)

    return transcript
  }
}
```

## Criterios de Aceite

- [ ] ChunkTranscriptUseCase divide em chunks de ~30s
- [ ] FetchTranscriptUseCase verifica cache primeiro
- [ ] Retorna do cache se existir (sem chamar YouTube)
- [ ] Busca do YouTube se nao cacheado
- [ ] Salva no cache apos buscar do YouTube
- [ ] Cobertura de testes: 80%+
- [ ] Todos os testes passam

## Validacao

```bash
pnpm test tests/unit/features/transcript/application/
pnpm test:coverage -- --coverage.include="src/features/transcript/application/**"
```

---

## Tags de Contexto

```
PRD: features/transcript
ARQUITETURA: dominios/transcript, decisoes/adr-004-cache-postgres
```

---

## Notas

- TDD recomendado: escrever teste antes do codigo
- Use case nao sabe detalhes de implementacao (Prisma, YouTube API)
- Injecao de dependencias via construtor
- Cache strategy: cache-first (verificar banco antes de buscar API)
