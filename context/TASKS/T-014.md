# T-014: Application - GenerateLessonUseCase

| Campo | Valor |
|-------|-------|
| **Tamanho** | M |
| **Prioridade** | Must Have |
| **Epic** | Lesson |
| **Depende de** | T-007, T-011, T-012, T-013 |
| **TDD** | Recomendado (80%) |

---

## Contexto

Criar use case que orquestra geracao de lesson: busca transcricao (usa FetchTranscriptUseCase), gera exercicios/vocabulario via IA, salva no banco.

## Objetivo

Use case completo para gerar lesson a partir de URL do YouTube.

## Escopo

- Implementar GenerateLessonUseCase
- Orquestrar: transcript → IA → lesson → persistencia
- Verificar se lesson ja existe (cache-first)
- Testes TDD com mocks

## Arquivos a Criar

```
src/features/lesson/
└── application/
    └── use-cases/
        └── generate-lesson.ts

tests/unit/features/lesson/
└── application/
    └── generate-lesson.test.ts
```

## Implementacao (TDD)

### 1. Testes

```typescript
// tests/unit/features/lesson/application/generate-lesson.test.ts
import { GenerateLessonUseCase } from '@/features/lesson/application/use-cases/generate-lesson'
import { Difficulty } from '@/features/lesson/domain/value-objects/difficulty'

describe('GenerateLessonUseCase', () => {
  const mockLessonRepo = {
    findByVideoId: vi.fn(),
    save: vi.fn()
  }

  const mockTranscriptUseCase = {
    execute: vi.fn()
  }

  const mockGenerator = {
    generate: vi.fn()
  }

  beforeEach(() => {
    vi.clearAllMocks()
  })

  it('should return cached lesson if exists', async () => {
    const cachedLesson = createMockLesson()
    mockLessonRepo.findByVideoId.mockResolvedValue(cachedLesson)

    const useCase = new GenerateLessonUseCase(
      mockLessonRepo,
      mockTranscriptUseCase,
      mockGenerator
    )

    const result = await useCase.execute({
      videoUrl: 'https://youtu.be/abc123',
      difficulty: Difficulty.medium()
    })

    expect(result.isSuccess).toBe(true)
    expect(result.value).toBe(cachedLesson)
    expect(mockTranscriptUseCase.execute).not.toHaveBeenCalled()
    expect(mockGenerator.generate).not.toHaveBeenCalled()
  })

  it('should generate new lesson if not cached', async () => {
    mockLessonRepo.findByVideoId.mockResolvedValue(null)
    mockTranscriptUseCase.execute.mockResolvedValue(
      Result.ok(createMockTranscript())
    )
    mockGenerator.generate.mockResolvedValue(
      Result.ok({
        exercises: [createMockExerciseData()],
        vocabulary: [createMockVocabularyData()]
      })
    )

    const useCase = new GenerateLessonUseCase(
      mockLessonRepo,
      mockTranscriptUseCase,
      mockGenerator
    )

    const result = await useCase.execute({
      videoUrl: 'https://youtu.be/abc123',
      difficulty: Difficulty.medium()
    })

    expect(result.isSuccess).toBe(true)
    expect(mockTranscriptUseCase.execute).toHaveBeenCalled()
    expect(mockGenerator.generate).toHaveBeenCalled()
    expect(mockLessonRepo.save).toHaveBeenCalled()
  })

  it('should return error if transcript fetch fails', async () => {
    mockLessonRepo.findByVideoId.mockResolvedValue(null)
    mockTranscriptUseCase.execute.mockResolvedValue(
      Result.fail(new TranscriptNotFoundError('abc123'))
    )

    const useCase = new GenerateLessonUseCase(
      mockLessonRepo,
      mockTranscriptUseCase,
      mockGenerator
    )

    const result = await useCase.execute({
      videoUrl: 'https://youtu.be/abc123',
      difficulty: Difficulty.medium()
    })

    expect(result.isFailure).toBe(true)
    expect(result.error).toBeInstanceOf(TranscriptNotFoundError)
  })

  it('should return error if AI generation fails', async () => {
    mockLessonRepo.findByVideoId.mockResolvedValue(null)
    mockTranscriptUseCase.execute.mockResolvedValue(
      Result.ok(createMockTranscript())
    )
    mockGenerator.generate.mockResolvedValue(
      Result.fail(new RateLimitError())
    )

    const useCase = new GenerateLessonUseCase(
      mockLessonRepo,
      mockTranscriptUseCase,
      mockGenerator
    )

    const result = await useCase.execute({
      videoUrl: 'https://youtu.be/abc123',
      difficulty: Difficulty.medium()
    })

    expect(result.isFailure).toBe(true)
    expect(result.error).toBeInstanceOf(RateLimitError)
  })

  it('should use provided difficulty level', async () => {
    mockLessonRepo.findByVideoId.mockResolvedValue(null)
    mockTranscriptUseCase.execute.mockResolvedValue(
      Result.ok(createMockTranscript())
    )
    mockGenerator.generate.mockResolvedValue(
      Result.ok({ exercises: [], vocabulary: [] })
    )

    const useCase = new GenerateLessonUseCase(
      mockLessonRepo,
      mockTranscriptUseCase,
      mockGenerator
    )

    await useCase.execute({
      videoUrl: 'https://youtu.be/abc123',
      difficulty: Difficulty.hard()
    })

    expect(mockGenerator.generate).toHaveBeenCalledWith(
      expect.anything(),
      expect.objectContaining({ value: 'hard' })
    )
  })
})
```

### 2. Implementacao

```typescript
// src/features/lesson/application/use-cases/generate-lesson.ts
import { LessonRepository } from '../../domain/interfaces/lesson-repository'
import { LessonGenerator, GeneratedLesson } from '../../domain/interfaces/lesson-generator'
import { Lesson } from '../../domain/entities/lesson'
import { Exercise } from '../../domain/entities/exercise'
import { VocabularyItem } from '../../domain/entities/vocabulary-item'
import { Difficulty } from '../../domain/value-objects/difficulty'
import { ExerciseType } from '../../domain/value-objects/exercise-type'
import { FetchTranscriptUseCase } from '@/features/transcript/application/use-cases/fetch-transcript'
import { VideoId } from '@/features/transcript/domain/value-objects/video-id'
import { Result } from '@/shared/lib/result'

export interface GenerateLessonInput {
  videoUrl: string
  difficulty: Difficulty
}

export type GenerateLessonError =
  | InvalidVideoUrlError
  | TranscriptNotFoundError
  | LessonGenerationError

export class GenerateLessonUseCase {
  constructor(
    private readonly lessonRepo: LessonRepository,
    private readonly fetchTranscript: FetchTranscriptUseCase,
    private readonly lessonGenerator: LessonGenerator
  ) {}

  async execute(
    input: GenerateLessonInput
  ): Promise<Result<Lesson, GenerateLessonError>> {
    // 1. Extrair VideoId
    const videoIdResult = VideoId.fromUrl(input.videoUrl)
    if (videoIdResult.isFailure) {
      return Result.fail(new InvalidVideoUrlError(input.videoUrl))
    }
    const videoId = videoIdResult.value

    // 2. Verificar cache de lesson
    const cachedLesson = await this.lessonRepo.findByVideoId(videoId)
    if (cachedLesson) {
      return Result.ok(cachedLesson)
    }

    // 3. Buscar transcricao (usa cache de transcript)
    const transcriptResult = await this.fetchTranscript.execute(input.videoUrl)
    if (transcriptResult.isFailure) {
      return Result.fail(transcriptResult.error)
    }
    const transcript = transcriptResult.value

    // 4. Gerar exercicios e vocabulario via IA
    const generationResult = await this.lessonGenerator.generate(
      transcript,
      input.difficulty
    )
    if (generationResult.isFailure) {
      return Result.fail(generationResult.error)
    }

    // 5. Criar entidades de dominio
    const exercisesResult = this.createExercises(generationResult.value.exercises)
    if (exercisesResult.isFailure) {
      return Result.fail(exercisesResult.error)
    }

    const vocabularyResult = this.createVocabulary(generationResult.value.vocabulary)
    if (vocabularyResult.isFailure) {
      return Result.fail(vocabularyResult.error)
    }

    // 6. Criar Lesson aggregate
    const lessonResult = Lesson.create({
      videoId,
      title: transcript.title,
      difficulty: input.difficulty,
      exercises: exercisesResult.value,
      vocabulary: vocabularyResult.value
    })

    if (lessonResult.isFailure) {
      return Result.fail(lessonResult.error)
    }

    // 7. Persistir
    await this.lessonRepo.save(lessonResult.value)

    return Result.ok(lessonResult.value)
  }

  private createExercises(
    data: GeneratedLesson['exercises']
  ): Result<Exercise[], ValidationError> {
    const exercises: Exercise[] = []

    for (const item of data) {
      const typeResult = ExerciseType.fromString(item.type)
      if (typeResult.isFailure) {
        return Result.fail(new ValidationError(`Invalid exercise type: ${item.type}`))
      }

      const exerciseResult = Exercise.create({
        type: typeResult.value,
        question: item.question,
        answer: item.answer,
        options: item.options,
        explanation: item.explanation,
        chunkIndex: item.chunkIndex
      })

      if (exerciseResult.isFailure) {
        return Result.fail(exerciseResult.error)
      }

      exercises.push(exerciseResult.value)
    }

    return Result.ok(exercises)
  }

  private createVocabulary(
    data: GeneratedLesson['vocabulary']
  ): Result<VocabularyItem[], ValidationError> {
    const vocabulary: VocabularyItem[] = []

    for (const item of data) {
      const vocabResult = VocabularyItem.create({
        word: item.word,
        definition: item.definition,
        example: item.example,
        partOfSpeech: item.partOfSpeech,
        chunkIndex: item.chunkIndex
      })

      if (vocabResult.isFailure) {
        return Result.fail(vocabResult.error)
      }

      vocabulary.push(vocabResult.value)
    }

    return Result.ok(vocabulary)
  }
}
```

## Criterios de Aceite

- [ ] Use case verifica cache de lesson primeiro
- [ ] Retorna lesson cacheada se existir
- [ ] Busca transcricao via FetchTranscriptUseCase
- [ ] Gera exercicios e vocabulario via LessonGenerator
- [ ] Cria entidades de dominio com validacao
- [ ] Persiste lesson no repositorio
- [ ] Trata erros de cada etapa corretamente
- [ ] Cobertura de testes: 80%+
- [ ] Todos os testes passam

## Validacao

```bash
pnpm test tests/unit/features/lesson/application/
pnpm test:coverage -- --coverage.include="src/features/lesson/application/**"
```

---

## Tags de Contexto

```
PRD: features/lesson
ARQUITETURA: dominios/lesson, padroes
```

---

## Notas

- TDD recomendado: escrever teste antes do codigo
- Use case orquestra multiplos servicos
- Injecao de dependencias via construtor
- Cada etapa tem tratamento de erro especifico
- Cache-first tanto para lesson quanto para transcript
