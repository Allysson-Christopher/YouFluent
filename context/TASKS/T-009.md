# T-009: Presentation - VideoPlayer + YouTube IFrame API

| Campo | Valor |
|-------|-------|
| **Tamanho** | M |
| **Prioridade** | Must Have |
| **Epic** | Player |
| **Depende de** | T-008 |
| **TDD** | E2E (Playwright) |

---

## Contexto

Implementar componente React VideoPlayer que usa YouTube IFrame API para reproduzir videos.

## Objetivo

Componente VideoPlayer funcional com integracao YouTube IFrame API e implementacao de PlayerAdapter.

## Escopo

- Componente VideoPlayer (React)
- YouTubePlayerAdapter (implementa PlayerAdapter)
- Integracao com YouTube IFrame API
- Controles de playback (play/pause, seek, rate)
- Testes E2E com Playwright

## Arquivos a Criar

```
src/features/player/
├── infrastructure/
│   └── adapters/
│       └── youtube-player-adapter.ts
└── presentation/
    └── components/
        ├── video-player.tsx
        └── video-player.test.tsx

tests/e2e/
└── player/
    └── video-player.spec.ts
```

## Implementacao

### 1. YouTubePlayerAdapter

```typescript
// src/features/player/infrastructure/adapters/youtube-player-adapter.ts
import { PlayerAdapter } from '../../domain/interfaces/player-adapter'
import { PlaybackState } from '../../domain/value-objects/playback-state'
import { TimePosition } from '../../domain/value-objects/time-position'

export class YouTubePlayerAdapter implements PlayerAdapter {
  private player: YT.Player | null = null
  private stateCallback: ((state: PlaybackState) => void) | null = null
  private timeCallback: ((time: TimePosition) => void) | null = null
  private timeUpdateInterval: NodeJS.Timeout | null = null

  constructor(private readonly elementId: string) {}

  async initialize(videoId: string): Promise<void> {
    return new Promise((resolve) => {
      this.player = new YT.Player(this.elementId, {
        videoId,
        events: {
          onReady: () => resolve(),
          onStateChange: (event) => this.handleStateChange(event)
        }
      })
    })
  }

  private handleStateChange(event: YT.OnStateChangeEvent): void {
    const state = this.mapYTState(event.data)
    this.stateCallback?.(state)
  }

  private mapYTState(ytState: number): PlaybackState {
    switch (ytState) {
      case YT.PlayerState.PLAYING: return PlaybackState.playing()
      case YT.PlayerState.PAUSED: return PlaybackState.paused()
      case YT.PlayerState.BUFFERING: return PlaybackState.buffering()
      case YT.PlayerState.ENDED: return PlaybackState.ended()
      default: return PlaybackState.paused()
    }
  }

  play(): void { this.player?.playVideo() }
  pause(): void { this.player?.pauseVideo() }
  seekTo(seconds: number): void { this.player?.seekTo(seconds, true) }
  getCurrentTime(): number { return this.player?.getCurrentTime() ?? 0 }
  getDuration(): number { return this.player?.getDuration() ?? 0 }

  getState(): PlaybackState {
    const ytState = this.player?.getPlayerState() ?? -1
    return this.mapYTState(ytState)
  }

  setPlaybackRate(rate: number): void {
    this.player?.setPlaybackRate(rate)
  }

  onStateChange(callback: (state: PlaybackState) => void): void {
    this.stateCallback = callback
  }

  onTimeUpdate(callback: (time: TimePosition) => void): void {
    this.timeCallback = callback
    this.startTimeUpdates()
  }

  private startTimeUpdates(): void {
    this.timeUpdateInterval = setInterval(() => {
      if (this.player && this.timeCallback) {
        const time = TimePosition.create(
          this.getCurrentTime(),
          this.getDuration()
        )
        this.timeCallback(time)
      }
    }, 100)
  }

  destroy(): void {
    if (this.timeUpdateInterval) clearInterval(this.timeUpdateInterval)
    this.player?.destroy()
  }
}
```

### 2. VideoPlayer Component

```typescript
// src/features/player/presentation/components/video-player.tsx
'use client'

import { useEffect, useRef, useCallback } from 'react'
import { YouTubePlayerAdapter } from '../../infrastructure/adapters/youtube-player-adapter'
import { usePlayerStore } from '../stores/player-store'

interface VideoPlayerProps {
  videoId: string
  onReady?: () => void
  onTimeUpdate?: (seconds: number) => void
}

export function VideoPlayer({ videoId, onReady, onTimeUpdate }: VideoPlayerProps) {
  const containerRef = useRef<HTMLDivElement>(null)
  const adapterRef = useRef<YouTubePlayerAdapter | null>(null)
  const { setAdapter, setPlaying, setCurrentTime } = usePlayerStore()

  useEffect(() => {
    const elementId = `youtube-player-${videoId}`

    const initPlayer = async () => {
      const adapter = new YouTubePlayerAdapter(elementId)
      await adapter.initialize(videoId)

      adapter.onStateChange((state) => setPlaying(state.isPlaying))
      adapter.onTimeUpdate((time) => {
        setCurrentTime(time.currentSeconds)
        onTimeUpdate?.(time.currentSeconds)
      })

      adapterRef.current = adapter
      setAdapter(adapter)
      onReady?.()
    }

    // Load YouTube IFrame API
    if (!window.YT) {
      const script = document.createElement('script')
      script.src = 'https://www.youtube.com/iframe_api'
      script.onload = () => {
        window.onYouTubeIframeAPIReady = initPlayer
      }
      document.body.appendChild(script)
    } else {
      initPlayer()
    }

    return () => {
      adapterRef.current?.destroy()
    }
  }, [videoId])

  return (
    <div className="aspect-video w-full">
      <div id={`youtube-player-${videoId}`} ref={containerRef} />
    </div>
  )
}
```

### 3. Teste E2E

```typescript
// tests/e2e/player/video-player.spec.ts
import { test, expect } from '@playwright/test'

test.describe('VideoPlayer', () => {
  test('should load and play YouTube video', async ({ page }) => {
    await page.goto('/lesson/dQw4w9WgXcQ') // Test video

    // Wait for player to load
    await expect(page.locator('#youtube-player-dQw4w9WgXcQ')).toBeVisible()

    // Click play
    await page.click('[data-testid="play-button"]')

    // Video should be playing
    await expect(page.locator('[data-testid="player-state"]')).toHaveText('playing')
  })

  test('should seek to specific time', async ({ page }) => {
    await page.goto('/lesson/dQw4w9WgXcQ')

    // Seek to 30 seconds
    await page.click('[data-testid="chunk-1"]') // Chunk starting at 30s

    // Current time should update
    await expect(page.locator('[data-testid="current-time"]')).toContainText('0:30')
  })
})
```

## Criterios de Aceite

- [ ] VideoPlayer carrega YouTube IFrame API
- [ ] YouTubePlayerAdapter implementa PlayerAdapter
- [ ] Controles play/pause funcionam
- [ ] Seek funciona corretamente
- [ ] Playback rate pode ser alterado
- [ ] Eventos de state change e time update disparam
- [ ] Cleanup correto ao desmontar componente
- [ ] Testes E2E passam

## Validacao

```bash
pnpm test:e2e tests/e2e/player/
```

---

## Tags de Contexto

```
PRD: features/player
ARQUITETURA: dominios/player, stack
```

---

## Notas

- YouTube IFrame API deve ser carregada dinamicamente
- Usar window.onYouTubeIframeAPIReady para callback
- Componente deve ser client-side only ('use client')
- Cleanup importante para evitar memory leaks
