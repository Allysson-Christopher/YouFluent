# T-013: Infrastructure - PrismaLessonRepository

| Campo | Valor |
|-------|-------|
| **Tamanho** | M |
| **Prioridade** | Must Have |
| **Epic** | Lesson |
| **Depende de** | T-011, T-002 |
| **TDD** | Testcontainers |

---

## Contexto

Implementar repositorio Prisma para persistir e buscar lessons no PostgreSQL.

## Objetivo

Repositorio que implementa LessonRepository com Prisma, salvando e buscando lessons com seus exercicios e vocabulario.

## Escopo

- Adicionar models Lesson, Exercise, VocabularyItem ao schema Prisma
- Implementar PrismaLessonRepository
- Implementar mapper Domain <-> Prisma
- Testes com Testcontainers

## Arquivos a Criar/Modificar

```
prisma/
└── schema.prisma              # Adicionar models Lesson, Exercise, VocabularyItem

src/features/lesson/
└── infrastructure/
    ├── repositories/
    │   └── prisma-lesson-repository.ts
    └── mappers/
        └── lesson-mapper.ts

tests/integration/features/lesson/
└── prisma-lesson-repository.test.ts
```

## Implementacao

### 1. Prisma Schema

```prisma
// prisma/schema.prisma (adicionar aos models existentes)

model Lesson {
  id         String   @id @default(cuid())
  videoId    String   @unique
  title      String
  difficulty String   @default("medium")
  createdAt  DateTime @default(now())
  updatedAt  DateTime @updatedAt

  exercises  Exercise[]
  vocabulary VocabularyItem[]

  @@index([videoId])
}

model Exercise {
  id          String   @id @default(cuid())
  type        String   // fill-blank, multiple-choice, translation, listening
  question    String   @db.Text
  answer      String
  options     String[] // Array de opcoes para multiple-choice
  explanation String?  @db.Text
  chunkIndex  Int

  lessonId String
  lesson   Lesson @relation(fields: [lessonId], references: [id], onDelete: Cascade)

  @@index([lessonId])
}

model VocabularyItem {
  id           String  @id @default(cuid())
  word         String
  definition   String  @db.Text
  example      String  @db.Text
  partOfSpeech String?
  chunkIndex   Int

  lessonId String
  lesson   Lesson @relation(fields: [lessonId], references: [id], onDelete: Cascade)

  @@index([lessonId])
}
```

### 2. Lesson Mapper

```typescript
// src/features/lesson/infrastructure/mappers/lesson-mapper.ts
import { Lesson as PrismaLesson, Exercise as PrismaExercise, VocabularyItem as PrismaVocab } from '@prisma/client'
import { Lesson } from '../../domain/entities/lesson'
import { Exercise } from '../../domain/entities/exercise'
import { VocabularyItem } from '../../domain/entities/vocabulary-item'
import { VideoId } from '@/features/transcript/domain/value-objects/video-id'
import { Difficulty } from '../../domain/value-objects/difficulty'
import { ExerciseType } from '../../domain/value-objects/exercise-type'

type PrismaLessonWithRelations = PrismaLesson & {
  exercises: PrismaExercise[]
  vocabulary: PrismaVocab[]
}

export class LessonMapper {
  static toDomain(data: PrismaLessonWithRelations): Lesson {
    const exercises = data.exercises.map(e =>
      Exercise.create({
        id: e.id,
        type: ExerciseType.fromString(e.type).value,
        question: e.question,
        answer: e.answer,
        options: e.options.length > 0 ? e.options : null,
        explanation: e.explanation ?? undefined,
        chunkIndex: e.chunkIndex
      }).value
    )

    const vocabulary = data.vocabulary.map(v =>
      VocabularyItem.create({
        id: v.id,
        word: v.word,
        definition: v.definition,
        example: v.example,
        partOfSpeech: v.partOfSpeech ?? undefined,
        chunkIndex: v.chunkIndex
      }).value
    )

    return Lesson.reconstitute({
      id: data.id,
      videoId: VideoId.create(data.videoId).value,
      title: data.title,
      difficulty: Difficulty.fromString(data.difficulty).value,
      exercises,
      vocabulary,
      createdAt: data.createdAt,
      updatedAt: data.updatedAt
    })
  }

  static toPrisma(lesson: Lesson): {
    lesson: Omit<PrismaLesson, 'id' | 'createdAt' | 'updatedAt'>
    exercises: Omit<PrismaExercise, 'id' | 'lessonId'>[]
    vocabulary: Omit<PrismaVocab, 'id' | 'lessonId'>[]
  } {
    return {
      lesson: {
        videoId: lesson.videoId.value,
        title: lesson.title,
        difficulty: lesson.difficulty.value
      },
      exercises: lesson.exercises.map(e => ({
        type: e.type.value,
        question: e.question,
        answer: e.answer,
        options: e.options ?? [],
        explanation: e.explanation ?? null,
        chunkIndex: e.chunkIndex
      })),
      vocabulary: lesson.vocabulary.map(v => ({
        word: v.word,
        definition: v.definition,
        example: v.example,
        partOfSpeech: v.partOfSpeech ?? null,
        chunkIndex: v.chunkIndex
      }))
    }
  }
}
```

### 3. PrismaLessonRepository

```typescript
// src/features/lesson/infrastructure/repositories/prisma-lesson-repository.ts
import { PrismaClient } from '@prisma/client'
import { LessonRepository } from '../../domain/interfaces/lesson-repository'
import { Lesson } from '../../domain/entities/lesson'
import { VideoId } from '@/features/transcript/domain/value-objects/video-id'
import { LessonMapper } from '../mappers/lesson-mapper'

export class PrismaLessonRepository implements LessonRepository {
  constructor(private readonly prisma: PrismaClient) {}

  async findByVideoId(videoId: VideoId): Promise<Lesson | null> {
    const data = await this.prisma.lesson.findUnique({
      where: { videoId: videoId.value },
      include: {
        exercises: { orderBy: { chunkIndex: 'asc' } },
        vocabulary: { orderBy: { chunkIndex: 'asc' } }
      }
    })

    return data ? LessonMapper.toDomain(data) : null
  }

  async save(lesson: Lesson): Promise<void> {
    const { lesson: lessonData, exercises, vocabulary } = LessonMapper.toPrisma(lesson)

    await this.prisma.lesson.create({
      data: {
        ...lessonData,
        exercises: { create: exercises },
        vocabulary: { create: vocabulary }
      }
    })
  }

  async update(lesson: Lesson): Promise<void> {
    const { lesson: lessonData, exercises, vocabulary } = LessonMapper.toPrisma(lesson)

    await this.prisma.$transaction([
      // Delete existing related records
      this.prisma.exercise.deleteMany({ where: { lessonId: lesson.id } }),
      this.prisma.vocabularyItem.deleteMany({ where: { lessonId: lesson.id } }),

      // Update lesson and recreate relations
      this.prisma.lesson.update({
        where: { id: lesson.id },
        data: {
          ...lessonData,
          exercises: { create: exercises },
          vocabulary: { create: vocabulary }
        }
      })
    ])
  }

  async delete(videoId: VideoId): Promise<void> {
    await this.prisma.lesson.delete({
      where: { videoId: videoId.value }
    })
  }
}
```

### 4. Testes com Testcontainers

```typescript
// tests/integration/features/lesson/prisma-lesson-repository.test.ts
import { PostgreSqlContainer, StartedPostgreSqlContainer } from '@testcontainers/postgresql'
import { PrismaClient } from '@prisma/client'
import { execSync } from 'child_process'
import { PrismaLessonRepository } from '@/features/lesson/infrastructure/repositories/prisma-lesson-repository'
import { Lesson } from '@/features/lesson/domain/entities/lesson'
import { VideoId } from '@/features/transcript/domain/value-objects/video-id'
import { Difficulty } from '@/features/lesson/domain/value-objects/difficulty'

describe('PrismaLessonRepository', () => {
  let container: StartedPostgreSqlContainer
  let prisma: PrismaClient
  let repository: PrismaLessonRepository

  beforeAll(async () => {
    container = await new PostgreSqlContainer().start()

    process.env.DATABASE_URL = container.getConnectionUri()
    execSync('pnpm prisma db push', { env: process.env })

    prisma = new PrismaClient()
    repository = new PrismaLessonRepository(prisma)
  }, 60000)

  afterAll(async () => {
    await prisma.$disconnect()
    await container.stop()
  })

  afterEach(async () => {
    await prisma.lesson.deleteMany()
  })

  it('should save and retrieve lesson with exercises and vocabulary', async () => {
    const lesson = createTestLesson()

    await repository.save(lesson)
    const found = await repository.findByVideoId(lesson.videoId)

    expect(found).not.toBeNull()
    expect(found?.videoId.value).toBe(lesson.videoId.value)
    expect(found?.exercises).toHaveLength(2)
    expect(found?.vocabulary).toHaveLength(3)
  })

  it('should return null for non-existent lesson', async () => {
    const videoId = VideoId.create('nonexistent123').value
    const found = await repository.findByVideoId(videoId)

    expect(found).toBeNull()
  })

  it('should update existing lesson', async () => {
    const lesson = createTestLesson()
    await repository.save(lesson)

    // Modify lesson
    const updatedLesson = Lesson.reconstitute({
      ...lesson,
      title: 'Updated Title'
    })

    await repository.update(updatedLesson)
    const found = await repository.findByVideoId(lesson.videoId)

    expect(found?.title).toBe('Updated Title')
  })

  it('should delete lesson and cascade to exercises/vocabulary', async () => {
    const lesson = createTestLesson()
    await repository.save(lesson)

    await repository.delete(lesson.videoId)

    const found = await repository.findByVideoId(lesson.videoId)
    expect(found).toBeNull()

    // Verify cascade
    const exerciseCount = await prisma.exercise.count()
    const vocabCount = await prisma.vocabularyItem.count()
    expect(exerciseCount).toBe(0)
    expect(vocabCount).toBe(0)
  })
})

function createTestLesson(): Lesson {
  return Lesson.create({
    videoId: VideoId.create('test123').value,
    title: 'Test Lesson',
    difficulty: Difficulty.medium(),
    exercises: [
      Exercise.create({
        type: ExerciseType.fillBlank(),
        question: 'I ___ happy',
        answer: 'am',
        options: null,
        chunkIndex: 0
      }).value,
      Exercise.create({
        type: ExerciseType.multipleChoice(),
        question: 'What is correct?',
        answer: 'Option A',
        options: ['Option A', 'Option B', 'Option C', 'Option D'],
        chunkIndex: 1
      }).value
    ],
    vocabulary: [
      VocabularyItem.create({
        word: 'happy',
        definition: 'Feeling joy',
        example: 'I am happy today.',
        chunkIndex: 0
      }).value,
      VocabularyItem.create({
        word: 'learn',
        definition: 'To gain knowledge',
        example: 'I want to learn English.',
        chunkIndex: 1
      }).value,
      VocabularyItem.create({
        word: 'study',
        definition: 'To apply the mind to learning',
        example: 'She studies every day.',
        chunkIndex: 1
      }).value
    ]
  }).value
}
```

## Criterios de Aceite

- [ ] Schema Prisma com Lesson, Exercise, VocabularyItem
- [ ] Migration aplicada com sucesso
- [ ] findByVideoId retorna null se nao existir
- [ ] findByVideoId retorna Lesson completa com relations
- [ ] save persiste Lesson com exercicios e vocabulario
- [ ] update atualiza lesson e relations
- [ ] delete remove lesson com cascade
- [ ] Mapper converte corretamente Domain <-> Prisma
- [ ] Testes com Testcontainers passando

## Validacao

```bash
pnpm prisma generate
pnpm prisma db push
pnpm test tests/integration/features/lesson/prisma-lesson-repository.test.ts
```

---

## Tags de Contexto

```
PRD: features/lesson
ARQUITETURA: dominios/lesson, decisoes/adr-002-prisma-7, decisoes/adr-004-cache-postgres
```

---

## Notas

- Testcontainers requer Docker rodando
- Cascade delete para manter integridade
- Ordenacao por chunkIndex para manter ordem
- Transaction para update atomico
